# üöÄ eConsultation AI - Complete Deployment Guide

## üìã Table of Contents

- [Overview](#overview)
- [Pre-Deployment Setup](#pre-deployment-setup)
- [GitHub Repository Setup](#github-repository-setup)
- [Cloud Platform Deployments](#cloud-platform-deployments)
- [Docker Deployment](#docker-deployment)
- [Environment Configuration](#environment-configuration)
- [CI/CD Pipeline](#cicd-pipeline)
- [Monitoring & Maintenance](#monitoring--maintenance)
- [Troubleshooting](#troubleshooting)

---

## üéØ Overview

This guide covers deploying the eConsultation AI system to various cloud platforms using GitHub as the source repository. The system includes:

- **Backend**: FastAPI with AI models (Python)
- **Frontend**: React application
- **Database**: PostgreSQL (production) / SQLite (development)
- **AI Models**: HuggingFace transformers for sentiment analysis and summarization

---

## üîß Pre-Deployment Setup

### 1. Prepare Your Local Repository

```bash
# 1. Initialize git repository (if not already done)
git init

# 2. Add all files
git add .

# 3. Commit your changes
git commit -m "Initial commit: eConsultation AI system"

# 4. Create GitHub repository and push
git remote add origin https://github.com/yourusername/econsultation-ai.git
git branch -M main
git push -u origin main
```

### 2. Create Required Configuration Files

We'll create these files for different deployment scenarios.

---

## üìÅ GitHub Repository Setup

### Repository Structure
```
econsultation-ai/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ build/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ .github/workflows/
‚îú‚îÄ‚îÄ deployment/
‚îî‚îÄ‚îÄ README.md
```

---

## ‚òÅÔ∏è Cloud Platform Deployments

## 1. üåê Render Deployment (Recommended - Free Tier Available)

### Backend Deployment on Render

Create `render.yaml`:
###
 Steps to Deploy on Render:

1. **Push to GitHub**:
```bash
git add .
git commit -m "Add deployment configurations"
git push origin main
```

2. **Connect to Render**:
   - Go to [render.com](https://render.com)
   - Connect your GitHub repository
   - Render will automatically detect the `render.yaml` file

3. **Environment Variables** (Set in Render Dashboard):
```
DATABASE_URL=postgresql://...  # Auto-generated by Render
ENVIRONMENT=production
CORS_ORIGINS=https://your-frontend-url.onrender.com
```

---

## 2. üî∑ Vercel + Railway Deployment

### Frontend on Vercel

1. **Connect GitHub to Vercel**:
   - Go to [vercel.com](https://vercel.com)
   - Import your GitHub repository
   - Set build settings:
     - Framework: React
     - Root Directory: `frontend`
     - Build Command: `npm run build`
     - Output Directory: `build`

2. **Environment Variables**:
```
REACT_APP_API_URL=https://your-backend.railway.app
```

### Backend on Railway

1. **Connect to Railway**:
   - Go to [railway.app](https://railway.app)
   - Create new project from GitHub
   - Select your repository

2. **Configure Railway**:
```json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "cd backend && python -m uvicorn app_optimized:app --host 0.0.0.0 --port $PORT",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

---

## 3. üåä DigitalOcean App Platform

Create `app.yaml`:
```yaml
name: econsultation-ai
services:
- name: backend
  source_dir: /backend
  github:
    repo: your-username/econsultation-ai
    branch: main
  run_command: python -m uvicorn app_optimized:app --host 0.0.0.0 --port $PORT
  environment_slug: python
  instance_count: 1
  instance_size_slug: basic-xxs
  envs:
  - key: ENVIRONMENT
    value: production
  health_check:
    http_path: /health

- name: frontend
  source_dir: /frontend
  github:
    repo: your-username/econsultation-ai
    branch: main
  build_command: npm run build
  run_command: npx serve -s build -p $PORT
  environment_slug: node-js
  instance_count: 1
  instance_size_slug: basic-xxs

databases:
- name: econsultation-db
  engine: PG
  version: "15"
```

---

## 4. ‚òÅÔ∏è AWS Deployment

### Using AWS App Runner

Create `apprunner.yaml`:
```yaml
version: 1.0
runtime: python3
build:
  commands:
    build:
      - cd backend
      - pip install -r requirements.txt
      - python instant_train.py
run:
  runtime-version: 3.11
  command: python -m uvicorn app_optimized:app --host 0.0.0.0 --port 8000
  network:
    port: 8000
    env: PORT
  env:
    - name: ENVIRONMENT
      value: production
```

### Using AWS ECS with Fargate

Create `task-definition.json`:
```json
{
  "family": "econsultation-ai",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::ACCOUNT:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "backend",
      "image": "your-account.dkr.ecr.region.amazonaws.com/econsultation-backend:latest",
      "portMappings": [
        {
          "containerPort": 8000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "ENVIRONMENT",
          "value": "production"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/econsultation-ai",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

---

## üê≥ Docker Deployment

### Local Docker Deployment

1. **Make deployment script executable**:
```bash
chmod +x deployment/deploy.sh
```

2. **Run deployment**:
```bash
./deployment/deploy.sh
```

3. **Access your application**:
   - Frontend: http://localhost:3000
   - Backend: http://localhost:8000
   - API Docs: http://localhost:8000/docs

### Production Docker Deployment

1. **Set up production environment**:
```bash
# Create production environment file
cp .env .env.production

# Edit production values
nano .env.production
```

2. **Deploy with production settings**:
```bash
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

---

## üîß Environment Configuration

### Backend Environment Variables

Create `backend/.env`:
```env
# Database
DATABASE_URL=postgresql://user:password@host:port/database
# or for SQLite: sqlite:///./eConsultation.db

# Application
ENVIRONMENT=production
LOG_LEVEL=INFO
SECRET_KEY=your-secret-key-here

# CORS
CORS_ORIGINS=https://your-frontend-domain.com,http://localhost:3000

# AI Models
MODEL_CACHE_DIR=./models
HUGGINGFACE_CACHE_DIR=./cache

# Monitoring
ENABLE_MONITORING=true
LOG_FILE_PATH=./logs/app.log
```

### Frontend Environment Variables

Create `frontend/.env`:
```env
REACT_APP_API_URL=https://your-backend-domain.com
REACT_APP_ENVIRONMENT=production
REACT_APP_VERSION=2.0.0
GENERATE_SOURCEMAP=false
```

---

## üîÑ CI/CD Pipeline Setup

### GitHub Secrets Required

Add these secrets to your GitHub repository:

```
# Render
RENDER_API_KEY=your-render-api-key
RENDER_SERVICE_ID=your-service-id

# Vercel
VERCEL_TOKEN=your-vercel-token
ORG_ID=your-org-id
PROJECT_ID=your-project-id

# Docker Registry
DOCKER_USERNAME=your-docker-username
DOCKER_PASSWORD=your-docker-password

# AWS (if using)
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=us-east-1
```

### Manual Deployment Commands

```bash
# Deploy to Render
curl -X POST \
  -H "Authorization: Bearer $RENDER_API_KEY" \
  -H "Accept: application/json" \
  -H "Content-Type: application/json" \
  https://api.render.com/v1/services/$SERVICE_ID/deploys

# Deploy to Vercel
npx vercel --prod --token $VERCEL_TOKEN

# Deploy to Railway
railway up --service backend
```

---

## üìä Monitoring & Maintenance

### Health Checks

```bash
# Backend health
curl https://your-backend-url.com/health

# Comprehensive health check
curl https://your-backend-url.com/health/comprehensive

# Performance metrics
curl https://your-backend-url.com/monitoring/performance
```

### Log Monitoring

```bash
# Docker logs
docker-compose logs -f backend
docker-compose logs -f frontend

# Application logs
tail -f backend/logs/app.log
tail -f backend/logs/error.log
```

### Database Maintenance

```sql
-- Check database size
SELECT pg_size_pretty(pg_database_size('econsultation'));

-- Optimize tables
VACUUM ANALYZE comments;

-- Check index usage
SELECT schemaname, tablename, attname, n_distinct, correlation 
FROM pg_stats WHERE tablename = 'comments';
```

---

## üö® Troubleshooting

### Common Issues

1. **Models not loading**:
```bash
# Rebuild with model download
docker-compose build --no-cache backend
```

2. **Database connection issues**:
```bash
# Check database logs
docker-compose logs db

# Test connection
docker-compose exec backend python -c "
import psycopg2
import os
conn = psycopg2.connect(os.getenv('DATABASE_URL'))
print('Connected successfully')
"
```

3. **Frontend build failures**:
```bash
# Clear npm cache
docker-compose exec frontend npm cache clean --force

# Rebuild frontend
docker-compose build --no-cache frontend
```

4. **Memory issues**:
```bash
# Check memory usage
docker stats

# Increase Docker memory limit
# Docker Desktop > Settings > Resources > Memory
```

### Performance Optimization

1. **Enable caching**:
```python
# In backend/app_optimized.py
ENABLE_MODEL_CACHE = True
CACHE_SIZE_LIMIT = 1000
```

2. **Database optimization**:
```sql
-- Add indexes for better performance
CREATE INDEX CONCURRENTLY idx_comments_text_search 
ON comments USING gin(to_tsvector('english', raw_text));
```

3. **Frontend optimization**:
```javascript
// Enable service worker caching
// In frontend/src/index.js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
```

---

## üîê Security Considerations

### Production Security Checklist

- [ ] Use HTTPS in production
- [ ] Set strong database passwords
- [ ] Enable CORS only for trusted domains
- [ ] Use environment variables for secrets
- [ ] Enable rate limiting
- [ ] Set up monitoring and alerting
- [ ] Regular security updates
- [ ] Backup database regularly

### SSL Certificate Setup

```bash
# Using Let's Encrypt with Certbot
sudo certbot --nginx -d your-domain.com

# Or using custom certificates
cp your-cert.pem deployment/ssl/cert.pem
cp your-key.pem deployment/ssl/key.pem
```

---

## üìà Scaling Strategies

### Horizontal Scaling

```yaml
# docker-compose.scale.yml
version: '3.8'
services:
  backend:
    deploy:
      replicas: 3
  
  nginx:
    image: nginx:alpine
    volumes:
      - ./deployment/nginx-lb.conf:/etc/nginx/nginx.conf
```

### Database Scaling

```yaml
# Add read replicas
db-replica:
  image: postgres:15-alpine
  environment:
    POSTGRES_MASTER_SERVICE: db
    POSTGRES_REPLICA_USER: replica
```

---

## üéØ Quick Start Commands

```bash
# 1. Clone and setup
git clone https://github.com/yourusername/econsultation-ai.git
cd econsultation-ai

# 2. Deploy locally
chmod +x deployment/deploy.sh
./deployment/deploy.sh

# 3. Deploy to cloud (choose one)
# Render: Push to GitHub, connect to Render
# Vercel: npx vercel --prod
# Railway: railway up
# DigitalOcean: doctl apps create app.yaml

# 4. Monitor deployment
curl http://localhost:8000/health
curl http://localhost:3000
```

---

## üìû Support & Resources

- **Documentation**: Check README.md for detailed setup
- **Issues**: Create GitHub issues for bugs
- **Monitoring**: Use `/health` endpoints for status
- **Logs**: Check application logs for debugging

---

**üéâ Your eConsultation AI system is now ready for production deployment!**

Choose the deployment method that best fits your needs and follow the corresponding steps. All configurations are production-ready with proper security, monitoring, and scaling capabilities.